IdentityServer4 is an OpenID Connect (Authentication) and OAuth 2.0 (token daðýtma) framework for ASP.NET Core.
( https://duendesoftware.com/  olmuþ)

identityserver4.readthedocs.io
------------------------------

https://oauth.net/



>>>>>> 
		1 - Authorize Endpoint : Front channel
		2 - Token Endpoint : Bakend channel

>>>>>> 
Return Type ( dönüþ tiplerini clientta belirtip bunlar gelsin diyebiliyorum : hibrit akýþ, doðrulamak için istersem) GrantTypes.Hybrid
code token (code : accesstoken)
code id_token > (server için en uygunu) (id_token : imzalý jwt token , içinde sadece kullanýcýId var, amacý : doðru yerden mi kontrolü için public key ile kontrol)
code id_token token (token direk jwt token)

OAuth 2.0 Grants :
---------------------------------------
1 - Authorization code grant :  login  >  Authorization code  flow     (GrantTypes.Code)
	Authorization Server'a 2 kere gidilir: 
		1 - Authorize Endpoint : username & password girilir karþýlýðýnda AuthorizationCode alýnýr
		2 - Token Endpoint : Alýnan AuthorizationCode ile yeniden Authorization Server'a  gidilir ve access token(w/ optional refresh token) alýnýr
		-> Identity Server bunu kendisi yapar, biz username & password gireriz ve direk token alýrýz. 
		-> Eðer OAuth2.0.Authorization code grant kendimiz kullanýrsak bu 2 aþamayý yapmalýyýz, Identity Server iþimii kolaylaþtýrýr burada.
Backend ise cookie, frontend/mobil ise access token(w/ optional refresh token) 
https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.1
2 - Implicit grant : 2 kere gidip gelinmez, 1 kere gidip kullancýý bilgileri girilir ve direk token alýnýr. mobil ve SPAlarda daha çok tercih edilen grant tipidir.
		1 -  Authorize Endpoint : direk 1 gidiþte token alýnýr.
https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.2
3 - Resource owner credentials grant* (=password): En kullanýlan akýþ tipi. Auth Server da , clientlar da , apilerde hepsi bizimse, kullanýcý anlamadan (auth server loginine yönlendirmeden, ben arka planda authservera gidip kontrol ediyorsam). fb ile vs giriþ yap demiyorsam akýþ tipim bu.  username & passwordu deðil token bilgilerini tutarým. Aþýrý çok client varsa logini authserverda yaptýrmak mantýklý merkezi olarak ama mobil ve web sitem varsa öyle biþey yapmam, kendi clientlarýmda loginlerle hallederim.
		1 - Token Endpoint : IdentityServer da client da güvenilirse (benimse), direk token alýyorum.
https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.3
4- Client credentials grant --> (Bu projede bunu yapýyoruz, bir tek bu grant tipinde refresh token kullanýlamaz : Üyelik sistemi yoksa)
		1 - Token Endpoint : üyelik sistemsiz, API'dan direl data almak için direk token alýyor.
https://datatracker.ietf.org/doc/html/rfc6749#section-1.3.4
 
ENDPOINTS : 
---------------------------------------
1 - Discovery Endpoint : projede olan endpointler ve urlleri, scopeler vs : /.well-known/openid-configuration
>>>> "jwks_uri": "https://localhost:7112/.well-known/openid-configuration/jwks"  sayesinde APIler publick key öðrenebiliyorlar (imza kontrolü sadece - doðru kiþi mi imzalamýþ yani, içerik doðrulama yok)
authorize Endpoint :
2 - Token Endpoint : token almak için : /connect/token
3 - UserInfo Endpoint : Kullanýcý hakkýnda Identity bilgilerini görmek için kullanýlýr, Config içinde Claimler ekledik kullanýcýnýn adý vs gibi "ek bilgiler", IdentityServer cookienin þiþmemesi için otomatik olarak User.Claims içinde bu bilgileri göstermedi, bu bilgilere iþte bu endpoint ile eriþebiliriz. Kullanýcnýn Bearer Tokený ile eriþilir. => bunu otomatik olarak yapmak için Client1.Program içinde AddOpenIdConnect içinde opts.GetClaimsFromUserInfoEndpoint =true ile IdentityServer'ýn direk bu bilgileri alýp Claims içinde getirmesini saðlayabiliriz. 
4 - Device authorization Endpoint :   tv gibi clientlar için data girmek zor olan
5 - Introspection Endpoint: eðer tokený parse edemiyorsan (içeriðini görebilecek bir libraryn yoksa) bana tokený yolla sana içeriðin, json olarak yollayayým diyor. -> Ýlgili tokenýn ilgili API için yetkisi var mý?
6 - Revocation Endpoint : tokený geçersiz kýlmak için (örn refresh token çalýnsa onunla yeni bir acces token almamasý içn o refresh tokený revoke ederiz)
7 - End session Endpoint :


Yetkilendirme : 
---------------------------------------
1 - Role based Authorization (adminiuser vs)
2 - Claim based Authorization ( yaþý 18 ve üstü olanlar vs. örn. dataya göre yetkilendirme yapýlmak istenirse)





CORS : Cross Origin Resource Sharing
---------------------------------------
Sadece tarayýcýdan ajax ile istek yaparken ilgili tarayýcý tarafýndan alýnan bir güvenlik önlemidir.
Tarayýcýdan API'ye bir ajax isteði yapýlacaksa o zaman APIlerde CORS özelliði açýlmalý : tarayýcý tarafýndan eklenen bu güvenlik duvarýný esnetmek için CORS eklenir
CORS açmak güvenlik eklemek deðil, tarayýcý tarafýndan eklenen güvenliði esnetmek içindir : güvenilir kaynaktýr bu , buradan gelen istekleri al, reddetme demek içindir.

Þuan eklemiyoruz çnk tarayýcýdan eriþmiyoruz burada APIlere. FE tarafýndan mesela Angular ile istek yapýnca CORS gerekecek. Þimdilik server-side sorguladýðýmýzdan gerekmiyor.


HttpClient : Client taraftan api isteði yapmak için HttpClient sýnýfýný kullanýcaz, get post put delete vs isteklerini yapmak için
IdentityModel (package) : istek gerçekleþtirince token yollamak gerekli, http header eklemek için. - normalde HttpClienta manuel eklemek gerek. Ama paketle HttpClient sýnýfýna yardýmcý methodlar geliyor. kolayca token alýp verebiliyoruz.HttpClient extension methodlarý var yani.

Antiforgery : formdan istek yapýnca httppost methodlarýna bizim tarafýmýzdan mý geldi kontrolü yapýyor. Token kontrolü : backend ve frontend tokený ayný mý ? 

Merkezi Login UI (IdentityServer Quickstart UI) : https://github.com/IdentityServer/IdentityServer4.Quickstart.UI

Clientlarda OpenIDConnect paketi indiriyorum : token gelmesi için (OpenID Connect (Authentication) and OAuth 2.0 (token daðýtma)), client token daðýtmayacaðýna göre OAuth gerekmiyor.





PKCE (Proof Key for Code Exchange) 
https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce
---------------------------------------
Secret nerede tutulmalý ?  sertverda kodda tutmayýz da SPA ve ya mobiede (nativede) nerede tutarsýn?
clientlarda OpenIdCOnnect paketleri bunu otomatik yaparlar.

merkezi üyelik sistemi kullanýyosak (hepsinin yönetimi bizdeyse client,Identity vs:  Resource Owner credentials Grant Type):  PKCE kullanmalý.
clientta kendi loginim var ise arkada username & password gönderilir buna gerek kalmaz.

------------------------------------------------------------------------------------------------------------------------------------------

Client1.ProductsController.IndexCentralized()

   HttpClient client = new HttpClient();
   var token = await HttpContext.GetTokenAsync(OpenIdConnectParameterNames.AccessToken);
   client.SetBearerToken(token);

Her bir istek get/post farketmez, yapacaðýmýz zaman bu 3 satýfý sabit kullanmamýz gerekecek, bunun yerine HttpContextAccessor kullanýrýz controllerýn arkasýndaki serviste, onun da Contexti var içinden token ve bilgilere eriþebiliriz.

HttpContext.GetTokenAsync(OpenIdConnectParameterNames.AccessToken);  >> satýrýndaki HttpContext controllerda var, ancak biz üstteki kýsmý merkezileþtr,p best practice ile servise taþýsak o nesne elimizde olmicak, bu nedenlde aþaðýdaki þekilde DI yaptýk ve artýk serviste de DI ile eriþebildik contexte ve her request için 3satýr yerine artýk elimizde tokený da olan bir client oldu ApiResourceHttpClient.GetHttpClient() ile.

builder.Services.AddHttpContextAccessor();
builder.Services.AddScoped<IApiResourceHttpClient, ApiResourceHttpClient>();